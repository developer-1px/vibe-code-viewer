# Vibe Coding IDE

> **"가장 뜨거운 새로운 프로그래밍 언어는 영어다" - Andrej Karpathy**

<br/>

## 📖 문제의 본질

### 인지 부하의 전환: 작성에서 읽기로

프로그래밍의 본질이 바뀌고 있습니다.

**과거**: 코드를 **쓰는** 것이 어려웠습니다.
- 한 줄씩 타이핑하며 논리를 구성
- 문법을 기억하고 알고리즘을 설계
- 내가 쓴 코드는 내 머릿속에 이미 존재

**현재**: 코드를 **읽는** 것이 어렵습니다.
- AI가 200줄을 3초 만에 생성
- 여러 파일을 동시에 수정
- 생성된 코드의 의도를 역설계해야 함

**이것은 단순한 도구의 변화가 아닙니다.**
**인지 부하(Cognitive Load)의 근본적인 전환입니다.**

전통적 코딩에서 병목은 "어떻게 구현할까?"였습니다.
바이브 코딩에서 병목은 "이게 뭘 한 거지?"입니다.

<br/>

### 속도와 규모의 불일치

**AI의 속도:**
- 초당 수백 줄 생성
- 동시에 10개 파일 수정
- 전체 아키텍처 리팩토링을 분 단위로 수행

**인간의 속도:**
- 분당 300자 읽기
- 한 번에 하나의 파일만 집중
- 맥락 전환에 수십 초 소요

**결과:**
우리는 2차원 도구(텍스트 에디터)로 3차원 구조(AI가 만든 복잡한 변경사항)를 이해하려 합니다.

마치 망원경 없이 은하를 관측하려는 것과 같습니다.
도구가 인식의 한계를 규정합니다.

<br/>

## 🧠 바이브 코딩 숙취 (Vibe Coding Hangover)

AI가 주말 동안 완벽한 프로젝트를 만들어줬습니다.
멋집니다. 하지만:

월요일 아침, 버그를 고쳐야 합니다.
어디서부터 봐야 할까요?

**이 파일이 어떤 역할을 하는지 모릅니다.**
내가 쓴 게 아니니까요.

**이 함수가 어디서 호출되는지 모릅니다.**
Find Usages를 누르면 50개가 나옵니다.
어떤 게 중요한지는 여전히 모릅니다.

**이 변수를 바꾸면 어디에 영향이 가는지 모릅니다.**
AI는 알고 있었지만, 나에게 알려주지 않았습니다.

**이것이 바이브 코딩 숙취입니다.**

생성은 빠르지만, 이해는 여전히 느립니다.
창조는 자동화되었지만, 유지보수는 수동입니다.

<br/>

## 🎭 역할의 변화: 작성자에서 감독자로

AI 시대, 개발자의 역할이 바뀌었습니다.

**작성자(Writer)** → **감독(Director)** → **설계자(Architect)**

더 이상 코드를 한 줄씩 타이핑하지 않습니다.
대신:
- 의도를 설명하고
- 결과를 검증하고
- 구조를 조율합니다

마치 DJ가 음악을 섞듯이,
마치 영화 감독이 씬을 구성하듯이,
마치 건축가가 공간을 설계하듯이.

**하지만 현재의 IDE는 여전히 "타자기" 메타포에 갇혀 있습니다.**

감독에게 펜과 종이만 주고 영화를 찍으라는 격입니다.

<br/>

## 🚨 현재 IDE의 근본적 한계

### 1. 파일 시스템의 물리적 구조에 갇혀 있습니다

```
src/
  components/
    user/
      profile/
        settings/
          notification/
            EmailPreferences.tsx
```

폴더 구조는 누군가의 머릿속 분류 체계일 뿐입니다.
실제 코드의 흐름과는 무관합니다.

우리가 정말 알고 싶은 건:
- "이 컴포넌트가 어떤 상태를 구독하나?"
- "이 API가 어디서 호출되나?"
- "이 데이터가 어디서 변경되나?"

**폴더 트리는 이런 질문에 답하지 않습니다.**

### 2. 변화 맹시 (Change Blindness)

AI가 한 번에 10개 파일을 수정했습니다.
Git diff를 엽니다:

```diff
- const user = getUser();
+ const user = await getUserAsync();
```

괜찮아 보입니다. 승인합니다.

**하지만 놓쳤습니다.**

다른 파일에서 이 함수를 동기적으로 호출하고 있었다는 걸.
컴포넌트 렌더링 로직 안에서.

이제 앱이 깨졌습니다.

**우리는 "무엇이 바뀌었는가"를 보지만**
**"무엇이 영향 받는가"는 보지 못합니다.**

### 3. 탭(Tab)의 감옥

파일 10개가 탭으로 열려 있습니다.
어떤 게 중요한지 기억이 안 납니다.
어떤 게 연관되어 있는지도 모릅니다.

탭을 하나씩 클릭해봅니다.
"아, 이건 아니고..."
"이것도 아니고..."
"이게 맞나? 아닌 것 같은데..."

**탭은 파일의 관계를 숨깁니다.**
**탭은 맥락을 파괴합니다.**

인간의 작업 기억(Working Memory)은 7±2개입니다.
AI는 한 번에 50개 파일을 건드립니다.

**우리의 뇌는 오버플로우됩니다.**

<br/>

## 💡 바이브 코딩이란 무엇인가

"바이브 코딩"은 코드를 쓰는 게 아니라, 코드의 **바이브(분위기, 구조, 본질)**를 이해하고 조율하는 것입니다.

AI가 코드를 생성하는 시대.
이제 중요한 것은:
- 코드를 **이해하는** 능력
- 아키텍처를 **설계하는** 직관
- 맥락을 **파악하는** 속도
- 품질을 **검증하는** 안목

**코드는 타이핑하는 게 아니라 지휘하는 것입니다.**

하지만 지휘자에게는 악보가 필요합니다.
교향악단의 전체 구조를 한눈에 볼 수 있는 악보.

**현재의 IDE는 한 번에 바이올린 파트 하나만 보여줍니다.**

<br/>

## 🔬 더 깊은 문제들

### 주체성의 스펙트럼 (Agency Spectrum)

AI와의 협업은 스펙트럼입니다:

**Human-in-the-Loop** (적극적 개입):
- 모든 함수 생성을 직접 지시
- 한 줄 한 줄 검토
- Copilot의 제안을 받아들이거나 거부

**Human-on-the-Loop** (감독적 개입):
- 고수준 목표 설정: "인증 시스템 리팩토링해"
- AI 에이전트가 계획 수립, 실행, 테스트
- 오류 발생 시에만 개입

**Human-out-of-the-Loop** (완전 위임):
- "주말 프로젝트 만들어줘"
- 결과물만 확인
- 코드 존재 자체를 잊어버림

**문제는 이 스펙트럼을 오가는 UI가 없다는 것입니다.**

감독 모드에서 일하다가, 필요할 때 특정 함수로 줌인하여 직접 수정하고, 다시 빠져나와 전체를 조망하는.

그런 유연한 인터페이스가 필요합니다.

### 설명 가능성과 신뢰 (Explainability & Trust)

AI가 코드를 만들었습니다.
왜 이 라이브러리를 선택했을까?
왜 이 패턴을 사용했을까?

**AI는 블랙박스입니다.**

맹목적으로 신뢰할 수 없습니다.
하지만 모든 코드를 읽을 수도 없습니다.

**AI의 결정 과정을 시각화해야 합니다.**
- 어떤 컨텍스트를 참조했는지
- 어떤 문서를 읽었는지
- 어떤 패턴을 적용했는지

출처(Provenance)가 명확해야 신뢰가 생깁니다.

### 의미론적 차이 vs 표면적 차이

전통적인 diff 도구:
```diff
+ 150 lines
- 148 lines
```

뭐가 바뀐 거죠?

변수명이 바뀐 건가?
로직이 바뀐 건가?
파일 위치만 옮긴 건가?
아니면 완전히 다시 쓴 건가?

**표면적 변화(Syntactic Diff)는 의도를 감춥니다.**

우리가 알고 싶은 건:
- "리팩토링인가, 기능 추가인가?"
- "어떤 동작이 변경되었는가?"
- "어디에 영향이 가는가?"

**의미론적 차이(Semantic Diff)가 필요합니다.**

<br/>

## 🌌 무엇이 필요한가

### 1. 공간적 사고 (Spatial Thinking)

인간은 **공간**을 기억합니다.
"왼쪽 상단에 DB 스키마가 있었고, 오른쪽에 API 핸들러가 있었다."

텍스트 목록보다 공간적 위치를 훨씬 잘 기억합니다.

**IDE는 공간이 되어야 합니다.**

무한 캔버스 위에:
- 연관된 파일들이 클러스터로 묶여 있고
- 의존성이 선으로 연결되어 있고
- 데이터 흐름이 시각적으로 보이는

그런 공간.

파일 트리는 보조 도구가 되고,
**구조 자체가 네비게이션이 되는** 환경.

### 2. 의미론적 줌 (Semantic Zoom)

모든 코드를 읽을 수는 없습니다.

줌 아웃하면:
- 실행 중인 앱의 라이브 프리뷰
- 아키텍처 다이어그램
- "OAuth 2.0 인증 처리" 같은 자연어 요약

줌 인하면:
- 제어 흐름 다이어그램
- 의사 코드
- 실제 소스 코드 (가장 깊이 들어갔을 때만)

**추상화 레벨을 동적으로 조절할 수 있어야 합니다.**

디버깅할 때만 코드로 내려가고,
설계할 때는 구조로 올라오는.

### 3. 질문 기반 네비게이션

파일을 여는 게 아니라, **질문을 던지는** 것이 탐색이어야 합니다.

"이 데이터가 어디서 오지?" → 역추적
"이 함수가 어디서 쓰이지?" → 순추적
"이걸 바꾸면 어디에 영향 가지?" → 영향도 분석

**질문이 곧 네비게이션입니다.**

### 4. 맥락의 지속성 (Persistent Context)

코드를 열면, 동시에 보여야 하는 것들:
- 이 코드가 시스템에서 어떤 위치에 있는지
- 이 코드가 어떤 데이터를 다루는지
- 이 코드를 부르는 호출자는 누구인지
- 이 코드를 고치면 어디가 깨지는지

**고립된 코드는 의미가 없습니다.**
**맥락 없는 코드는 이해할 수 없습니다.**

### 5. AI와의 공간적 대화

채팅창에 텍스트를 타이핑하는 게 아니라:

캔버스에서 "이 모듈"을 손가락으로 가리키며
"이 흐름에 로깅 추가해"라고 말하는.

프롬프트를 코드 블록 옆에 **직접** 배치하는.

**공간 프롬프팅(Spatial Prompting):**
맥락을 설명하지 않아도 되는,
가리키기만 하면 되는 인터페이스.

<br/>

## 🎯 핵심 믿음

### "코드는 텍스트가 아니라 구조다"

코드를 텍스트로 보는 한, 우리는 계속 Ctrl+F를 누를 것입니다.
코드를 구조로 보기 시작하면, 완전히 다른 도구가 가능해집니다.

추상 구문 트리(AST), 의존성 그래프, 데이터 흐름.
이것이 코드의 본질입니다.

텍스트는 그저 하나의 **투영(Projection)**일 뿐입니다.

### "IDE는 타자기가 아니라 현미경이다"

AI 시대의 IDE는 입력 도구가 아닙니다.
관찰 도구입니다.

- 보이지 않는 구조를 보이게 하고
- 복잡한 관계를 단순하게 표현하고
- 거대한 시스템을 이해 가능하게 만드는

**인지 확장 도구(Cognitive Amplifier)**여야 합니다.

### "프론트엔드 개발자는 다르게 생각한다"

우리는 매일:
- 컴포넌트 트리를 그립니다
- 상태 흐름을 추적합니다
- 의존성 체인을 관리합니다

우리의 사고는 본질적으로:
- 시각적이고
- 구조적이고
- 상호작용적입니다

**그런데 왜 우리 도구는 1970년대 터미널 에디터의 메타포에 갇혀 있을까요?**

<br/>

## 🧪 실험으로서의 프로젝트

이 프로젝트는 **정답을 제시하지 않습니다.**

대신 **질문을 탐구합니다:**

- 어떻게 하면 AI가 만든 코드를 빠르게 이해할 수 있을까?
- 어떻게 하면 맥락을 잃지 않고 탐색할 수 있을까?
- 어떻게 하면 감독자로서 AI를 효과적으로 지휘할 수 있을까?
- 어떻게 하면 구조를 보고, 만지고, 조율할 수 있을까?

그래프 뷰도 실험입니다.
다른 방식도 시도하고 있습니다.
더 나은 방법을 찾으면 그것도 시도할 것입니다.

**이것은 여정입니다.**

<br/>

## 🌊 왜 "바이브(Vibe)"인가

Vibe는 분위기, 느낌, 본질을 의미합니다.

코드의 바이브를 느낀다는 것은:
- 세세한 문법을 보기 전에 전체 구조를 파악하고
- 흐름의 리듬을 이해하고
- "이 코드가 주는 느낌"을 직관적으로 아는 것

마치 음악을 들을 때:
악보를 읽지 않아도 곡의 흐름을 느끼듯이.

마치 건축물을 볼 때:
설계 도면을 보지 않아도 공간의 의도를 이해하듯이.

**코드도 그렇게 "느낄" 수 있어야 합니다.**

<br/>

---

## 📚 더 깊이 알아보기

- **`CLAUDE.md`** - 프로젝트 아키텍처, 기술적 디테일
- **`CONVENTIONS.md`** - 코딩 컨벤션, 아키텍처 규칙
- **`docs/2-Areas/Architecture/`** - 아키텍처 결정 기록

<br/>

## 🤝 함께 실험하기

만약 당신도:
- "AI가 만든 코드를 이해하기 어렵다"고 느낀다면
- "코드를 읽는 게 코드를 쓰는 것보다 어렵다"고 생각한다면
- "IDE가 근본적으로 바뀌어야 한다"고 믿는다면
- "더 나은 방식이 있을 것 같다"는 직감이 든다면

함께 실험해봅시다.

버그 리포트, 아이디어, PR 모두 환영합니다.

<br/>

```bash
npm install
npm run dev
```

<br/>

---

**"문제를 다르게 보면, 해결책도 달라진다."**

**"코드를 보는 방식이 바뀌면, 코드를 다루는 방식도 바뀐다."**
